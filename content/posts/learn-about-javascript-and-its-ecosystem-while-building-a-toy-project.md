---
date: '2025-10-12T15:23:53+02:00'
title: 'Learn About JavaScript and Its Ecosystem While Building a Toy Project ðŸª€'
tags: ["javascript", "node", "vite", "typescript", "express", "mongodb"]
categories: ["full-stack"]
---
##### Disclaimer: This is not something anyone would normally do, but because we are learning, this is exactly what we want to do. This will give you a better understanding of the moving parts and why you later would want to use a framework that basically do all of this for you.

### Steps to take...

...to build a full-stack [Node](https://nodejs.org/en)/[Express](https://expressjs.com/) app serving a [Single-page application (SPA)](https://developer.mozilla.org/en-US/docs/Glossary/SPA) with client-side navigation using Vite as build tool.

- Pick a project you want to build e.g. a blog or a portfolio.
- Use [Node](https://nodejs.org/en) as backend environment.
- Use [Vite](https://vite.dev/) as build tool.
- Use [TypeScript](https://www.typescriptlang.org/).
- Use [Express](https://expressjs.com/) as web server.
- Use [Fetch (Fetch API)](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API).
- Use [Vitest](https://vitest.dev/) to unit test.
- Use [Playwright](https://playwright.dev/) to end-2-end test.
- Use [GitHub](https://github.com/) and [GitHub Actions](https://github.com/features/actions).
- Use [MongoDB](https://www.mongodb.com/) with [Node native MongoDB client driver](https://www.mongodb.com/docs/drivers/node/current/).
- Host the production app on [Render.com](https://render.com/).
- Host the production MongoDB on [MongoDB Atlas](https://www.mongodb.com/products/platform/atlas-database).

You can read more about each technology on the specific websites, and you can use AI-tools to help you better understand why they exist and why we use them. In this guide I'll provide simple explanations, but the focus is on the code itself.

### Let's get started

I'm running macOS, you need to replace the terminal commands to match your OS.

- Make sure you have Node installed on your system.
- Make sure you have a text editor e.g. Visual Studio Code

### Create a Vite project

Vite is a build tool for the JavaScript ecosystem, it transforms different types of code like TypeScript into pure Javascript that the browser and other runtimes can understand. This tool is essential for us to develop modern web applications.

We start [creating a new Vite project](https://vite.dev/guide/#scaffolding-your-first-vite-project) without framework (Vanilla), with TypeScript and without rolldown-vite:
```bash
npm create vite@latest my-project
```
output:
```bash
â—‡  Select a framework:
â”‚  Vanilla
â”‚
â—‡  Select a variant:
â”‚  TypeScript
â”‚
â—‡  Use rolldown-vite (Experimental)?:
â”‚  No
â”‚
â—‡  Install with npm and start now?
â”‚  No
```

We then follow the instructions to navigate into our project, installing all dependencies, and starting the dev server: 
```bash
 cd my-project
 npm install
 npm run dev
```
output:
```bash
  VITE v7.1.9  ready in 269 ms

  âžœ  Local:   http://localhost:5173/
  âžœ  Network: use --host to expose
  âžœ  press h + enter to show help
```

Open the browser and navigate to [http://localhost:5173/](http://localhost:5173/) to view the app.

This is the default app generated by the Vite team, now we'll begin buidling our own app.

### What's in our project so far?

We have the basic directories and files to build a JavaScript app. 

The node_modules directory contains all installed dependencies that we need to develop our project, it's to large to list but check it out for yourself, you'll find vite in there.
```bash
.
â”œâ”€â”€ .gitignore
â”œâ”€â”€ index.html
â”œâ”€â”€ node_modules
â”œâ”€â”€ package-lock.json
â”œâ”€â”€ package.json
â”œâ”€â”€ public
â”‚Â Â  â””â”€â”€ vite.svg
â”œâ”€â”€ src
â”‚Â Â  â”œâ”€â”€ counter.ts
â”‚Â Â  â”œâ”€â”€ main.ts
â”‚Â Â  â”œâ”€â”€ style.css
â”‚Â Â  â””â”€â”€ typescript.svg
â””â”€â”€ tsconfig.json
```

I'll explain their purpose:

.gitignore
: This file tells git what not to commit to our repository.

index.html
: This file is the starting point for our frontend.

/node_modules
: This directory is where all dependencies lives. Whenever we install a new package it ends up in here.

package-lock.json
: This file keeps track of all installed dependencies, and their respective dependencies. We do not touch this file, it's entirely managed by our package manager (npm).

package.json
: This file is our projects configuration file, in here we specify what dependecies we want to include and what scripts we want to run, e.g. the dev script which starts our dev server.

/public
: This directory contains images and other static files which are not HTML, CSS, or JavaScript.

/src
: This directory is where we keep most of our projects source files, i.e. where we keep most of our application code. 

tsconfig.json
: This file is our projects TypeScript configuration file, we use this file to tell the TypeScript Server what we expect it to behave while interacting with our projects code.  

#### Again, use AI-tools to further explain the files and directories.

### Let's do some cleaning ðŸ§¹

Before we add our own files we remove the files inside /src and /public. These files are not needed to run our application, they are there to run the current default application.

- Remove vite.svg
- Remove counter.ts
- Remove main.ts
- Remove style.css
- Remove typescript.svg

Now we're ready to start adding our own code. I'll walk you through the steps.

### Soon we start coding, let's start with project structure

We want to split our backend and frontend code into two seperate directories, and to have it organised we create the directories inside our /src directory: 

```bash
src/
â”œâ”€â”€ backend
â””â”€â”€ frontend
```

We keep the index.html file in the root directory of our project, this is still the entry point for our frontend/client code.

Now we create the file that will act as the entry point for our backend/server code. 

- Create a file and name it server.ts and place it in the root directory of the project.

Your project structure should look like this: 

```bash
.
â”œâ”€â”€ index.html
â”œâ”€â”€ node_modules
â”œâ”€â”€ package-lock.json
â”œâ”€â”€ package.json
â”œâ”€â”€ public
â”œâ”€â”€ server.ts
â”œâ”€â”€ src
â”‚   â”œâ”€â”€ backend
â”‚   â””â”€â”€ frontend
â””â”€â”€ tsconfig.json
```

To explain, we run our app in developmenr by calling the server.ts file with a package called tsx that can run the TypeScript file. Later in production when the project is already transpiled into JavaScript we use Node.

```bash
# in development: 
tsx server.ts
# in production: 
node server.js
```

It's inside this server.ts/js file we initialise our application and serve the client code as static files through our express web server. 

On top of that we use Vite in development, as an express middleware, to get all the benefits Vite provides, e.g. [HMR (Hot Module Replacement)](https://vite.dev/guide/features.html#hot-module-replacement) which updates the browser output automatically on code changes in our editor. 

Don't worry, this will soon all make sense.

In order to have full TypeScript support we add our server.ts file to our tsconfig.json:

```js
"include": ["src", "server.ts"]
```

Before we start coding we add some more fundamental files to our project structure.

- Create a file named router.ts inside your /src/frontend directory.
- Create a file named routes.ts inside your /src/frontend directory.
- Create a directory named pages inside your /src/frontend directory.
- Create a directory named controllers inside your /src/backend directory.
- Create a file named db.ts inside yout /src/backend directory.

Your project structure should look like this:

```bash
.
â”œâ”€â”€ index.html
â”œâ”€â”€ node_modules
â”œâ”€â”€ package-lock.json
â”œâ”€â”€ package.json
â”œâ”€â”€ public
â”œâ”€â”€ server.ts
â”œâ”€â”€ src
â”‚   â”œâ”€â”€ backend
â”‚   â”‚   â”œâ”€â”€ controllers
â”‚   â”‚   â””â”€â”€ db.ts
â”‚   â””â”€â”€ frontend
â”‚       â”œâ”€â”€ pages
â”‚       â”œâ”€â”€ router.ts
â”‚       â””â”€â”€ routes.ts
â””â”€â”€ tsconfig.json
```

To prevent the app from crashing when we later start it, change the src value inside the script tag inside the index.html to reference your router.ts file:

```html
<script type="module" src="src/frontend/router.ts"></script>
```

### Let's build the backend and glue it to the frontend

Just to recap what happens Whenever a user decides to visit our webpage. Their browser sends a HTTP request asking for whatever we serve at the specific location, usually "/" which could be thought of as "Home". E.g. https://example.com 

When that happens we want to send back a HTTP response, and to do that we need to setup an express web server that listens to incoming requests and serves our SPA.

**We install a couple of packages to get going.**

The -D flag installs a package only to the devDependencies to use only in development.

To please TypeScript we install types for Node:

```bash
npm i -D @types/node 
```

Then the tsx package which allows us to run our server.ts file in development:

```bash
npm i -D tsx
```

Finally, install express and its types:

```bash
npm i express && npm i -D @types/express
```

Place the following code inside your server.ts file:

```js
import express, { type Response } from "express";
import path from "path";
import { fileURLToPath } from "url";

const port = 3000;

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

async function main() {
  const app = express();
  app.get("/", ({ res }: { res: Response }) => {
    res.sendFile(path.join(__dirname, "index.html"));
  });
  app.listen(port, () => {
    console.log(`running server at http://localhost:${port}`);
  });
}

main().catch((error) => console.log(error));
```

Change the dev script inside package.json to run with tsx:
```js
"dev": "tsx server.ts"
```

Then run the server from the terminal:

```bash
npm run dev
```

It should give an output like this: 

```bash
> my-project@0.0.0 dev
> tsx server.ts

running server at http://localhost:3000
```

Visit the site, it's only a blank page, but the title of the site should be "my-project". 

**Hint: The title is visible in the tab at the top of the browser.**

### What's happening right now?

Let's break it down...

We import the express package and its types to be able to build the web server:
```js
import express, { type Response } from "express";
```

We import the path package which allows us to easily write and handle path strings. This is important to tell the code inside the current module how to navigate the filesystem:
```js
import path from "path";
```

The third import is a function that allows us to transform a file url into a path that the path package can understand:
```bash
# file url
file:///Users/vide/code/my-project/server.ts
# file path
/Users/vide/code/my-project/server.ts
```
```js
import { fileURLToPath } from "url";
```

We assign the port number to a constant, and populate the current filename and dirname to two other constant: 

```js
const port = 3000; // port number for our server

const __filename = fileURLToPath(import.meta.url); // server.ts
const __dirname = path.dirname(__filename); // /Users/vide/code/my-project/
```

- We wrap our express server inside a main function.
- We create a "GET" endpoint for the express server and serve our index.html file when the site is visited.
- We tell express to listen on our predefined port and console.log that it is running.
- Finally, we initialise the main function with a catch handler to console.log any errors. 

```js
async function main() {
  const app = express();
  app.get("/", ({ res }: { res: Response }) => {
    res.sendFile(path.join(__dirname, "index.html"));
  });
  app.listen(port, () => {
    console.log(`running server at http://localhost:${port}`);
  });
}

main().catch((error) => console.log(error));
```

### Time to connect Vite with Express 

##### [View the source](https://vite.dev/guide/ssr)

In order to have the benefits of Vite in our development process, we need to set it up as a Express middleware and tell it to serve our frontend code as a SPA. 

We need to distinguish between dev mode and production mode, and the easiest way to do that is to set an environment variable in our package.json scripts.

There is a great package we can use to achieve this rather hassle free: [cross-env](https://www.npmjs.com/package/cross-env). This package can be used on macOS, Windows, and Linux.

```bash
npm i cross-env
```

It's ready to be used in our production script later on, for now we do not need to worry about it, because the absence of the environment variable is equal to false.

#### Continuing with Vite: 
When we run Vite as a middleware, Vite also want to know where to find our index.html, but Vite will look for index.html by default so we do not need to specify the exact file to find, as we did above with pure a Express server, only the directory where it is.

Now we need to change the rest of our server.ts file. 

```js
import express, { type Response } from "express";
import path from "path";
import { fileURLToPath } from "url";

const port = 3000;
const isProduction = process.env.NODE_ENV === "production";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

async function main() {
  const app = express();

  let vite;
  if (!isProduction) {
    const { createServer: createViteServer } = await import("vite");
    vite = await createViteServer({
      server: { middlewareMode: true },
      appType: "spa",
      root: __dirname,
    });
    app.use(vite.middlewares);
  } else {
    app.get("/", ({ res }: { res: Response }) => {
      res.sendFile(path.join(__dirname, "index.html"));
    });
  }
  app.listen(port, () => {
    console.log(
      `running ${
        isProduction ? "PROD" : "DEV"
      } server at http://localhost:${port}`
    );
  });
}

main().catch((error) => console.log(error));
```

This checks if we are in dev or production then run correct code:
```js
let vite;
  if (!isProduction) {
    const { createServer: createViteServer } = await import("vite");
    vite = await createViteServer({
      server: { middlewareMode: true },
      appType: "spa",
      root: __dirname,
    });
    app.use(vite.middlewares);
  } else {
    app.get("/", ({ res }: { res: Response }) => {
      res.sendFile(path.join(__dirname, "index.html"));
    });
  }
```

We also add this to print to the console what type of server we are running:
```js
  app.listen(port, () => {
    console.log(
      `running ${
        isProduction ? "PROD" : "DEV"
      } server at http://localhost:${port}`
    );
  });
```

To test that everything is working as expected, we start our dev server then visit the web page in the browser, then we add a h1 tag inside our index.html file saying "Hello, World!" and save. It should render in the browser without any server restart. 

Remove the h1 tag before moving on.

### Client-side navigation and routing 

To achieve client-side navigation without using an external framework we need to work with some properties and methods of the JavaScript [Window object](https://developer.mozilla.org/en-US/docs/Web/API/Window). 

The window object, through its properties and methods, gives us access to the browserâ€™s built-in functionalities that allow us to control navigation and manage the browser history.

Let's walk it through to get a better understanding of how it all works.

What we need:

1. Navigation links ([anchor elements](https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Elements/a)) for the user to click to visit each page.
2. "Container" html element where we dynamically render our pages content.
3. [Custom data attribute](https://developer.mozilla.org/en-US/docs/Web/HTML/How_to/Use_data_attributes) to allow us to target our links with JavaScript.
4. Decide on page layout that will render each page.
5. JavaScript function that listens to link clicks and render the correct page content.
6. JavaScript function that updates the browsers history throught the History API.
7. JavaScript function that listens to back and forward navigations with the browser, and render the correct pages content.

**Since we are using TypeScript we will type everything.**

We start with adding our navigation links and the container element to the index.html file. We add them inside the already created div element that has the id="app".

```html 
<!-- other html code -->
<div id="app">
  <nav id="navigation">
    <a href="/" data-link>Home</a>
    <a href="/dashboard" data-link>Dashboard</a>
  </nav>
  <div id="page-content"></div>
</div>
<!-- other html code -->
```

Next, we define the types for our pages and routing functions. 

Inside the frontend directory, create a new file called types.ts:
```js
// this is used for our page functions
export type RouteEntry = {
  html: () => string;
  // we make this async to be sure we can run async code further down the line
  logic: async () => void;
};

// this is used by our router function
export type Routes = Record<string, RouteEntry>;
```

We define that our pages (RouteEntry) will return an object with two functions, one that return the html, and one that returns the page logic.

Now, let's create our home page and our dashboard page, and while at it we also create a page for any request to a page that does not exists, i.e. "page not found, 404".

```js
import type { RouteEntry } from "../types";

export function HomePage(): RouteEntry {
  return {
    html: () => `
        <h1>Home Page</h1>
    `, // this is where you return your page html
    logic: async () => {
      // this is where you write your page logic
      // e.g. console.log("Hello from home page");
    },
  };
}

```

Create all three and put them inside the /src/frontend/pages directory: 
```bash 
pages
â”œâ”€â”€ 404.ts
â”œâ”€â”€ dashboard.ts
â””â”€â”€ home.ts
```

Inside the routes.ts file we import the Routes type from types.ts and all the pages from their respective files, and then export our routes object, and a type for the pathName that we will use in our router function: 
```js
import type { Routes } from "./types";
import { HomePage } from "./pages/home";
import { DashboardPage } from "./pages/dashboard";
import { PageNotFound } from "./pages/404";

export const routes = {
  "404": PageNotFound(),
  "/": HomePage(),
  "/dashboard": DashboardPage(),
} satisfies Routes;

export type pathName = keyof typeof routes;
```

Finally we add the functionality to our router.ts module:
```js
import { routes, type pathName } from "./routes";

// function to render the page content
async function renderContent(pathname: pathName) {
  // target the page-content element inside index.html
  const contentElement = document.getElementById("page-content");
  if (contentElement) {
    // render the page html
    contentElement.innerHTML = routes[pathname].html();
    // render the page logic
    await routes[pathname].logic();
  }
}

// function to navigate to a page
function navigateTo(pathname: string) {
  // check if pathname is part of our routes object
  if (pathname in routes) {
    // render page content
    renderContent(pathname as pathName);
  } else {
    // render 404 page
    renderContent("404");
  }
  // push new state to browser history to enable browser back and forward press
  history.pushState({ pathname: pathname }, "", pathname);
}

// target all the links inside our index.html file
document.querySelectorAll<HTMLAnchorElement>("a[data-link]").forEach((link) => {
  // add event listener for click
  link.addEventListener("click", (e) => {
    // prevent from navigating with full page reload
    e.preventDefault();
    // extract the url from the target href
    const url = new URL(link.href);
    // provide the pathname
    navigateTo(url.pathname);
  });
});

// handle back and forward navigations from the browser
window.addEventListener("popstate", (e) => {
  // check that state is valid
  if (e.state && "pathname" in e.state) {
    if (e.state.pathname in routes) {
      // then render correct page
      renderContent(e.state.pathname);
    } else {
      // or 404
      renderContent("404");
    }
  }
});

// Initial site render when the JavaScript is loaded into the browser
const initialPath = window.location.pathname;
// set the history state to the current path
history.replaceState({ pathname: initialPath }, "", initialPath);
// render first page that user visits
if (initialPath in routes) {
  renderContent(window.location.pathname as pathName);
} else {
  renderContent("404");
}
```

Now we can use our client-side navigation ðŸŽ‰

### Writing page logic and corresponding Express routes

Let's write a small form that can create and edit blog posts and place it in dashboard.ts:

```html
<form method="post" id="blog-form">
  <label for="blog-title">Blog Title</label>
  <input type="text" name="blog-title" id="blog-title">
  <label for="blog-text">Blog Text</label>
  <textarea name="blog-text" id="blog-text" rows="4" cols="12"></textarea>
  <button id="submit-button">Create Post</button>
</form>
```

We create the JavaScript logic that handle the form submit:

```js
// we add an event listner to the submit button
blogForm.addEventListener("submit", async (e) => {
  // prevent the form submit
  e.preventDefault();
  // we add the input values to an object 
  const formData: BlogPostFormData = {
    blogTitle: blogTitle.value,
    blogText: blogText.value,
  };
  // and send the data to the backend
  try {
    const response = await fetch("http://localhost:3000/dashboard", {
      // using post method
      method: "post",
      // declare we use json format
      headers: {
        "content-type": "application/json",
      },
      // then parse our data into json
      body: JSON.stringify(formData),
    });
    // we read the response from the server
    // ... 
    // then remove value from form input fields
    blogTitle.value = "";
    blogText.value = "";
  } catch (error) {
    console.log(error);
  }
});
```

It's time to create the backend route to receive and save the data, including the database logic. **This also gives us a good opportunity to write some tests!**

#### These are the steps to take: 

1. Install MongoDB, MongoDB client, and mongodb-memory-server (to test our code)
2. Write MongoDB logic 
3. Write the Express route to receive incoming form data
4. Write a data validation function to validate incoming form data
5. Install Vitest and test the validate function
6. Install Playwright and test our form including saving to the test database

[Install the MongoDB community edition.](https://www.mongodb.com/try/download/community) 

[Install the MongoDB shell](https://www.mongodb.com/docs/mongodb-shell/install/#procedure) **and use it to create a new database named "my-project".**

Install the [Node native MongoDB client](https://www.mongodb.com/docs/drivers/node/current/get-started/#install-the-node.js-driver), and the [mongodb-memory-server](https://github.com/typegoose/mongodb-memory-server):

```bash
npm i mongodb && npm i -D mongodb-memory-server
```

[Install the dotenv package](https://www.npmjs.com/package/dotenv) that let's us use environment variables inside .env file. We use this for our production database connection string, because it will contain credentials that we want to keep secret.

```bash
npm i dotenv
```

Load dotenv in the top of the server.ts file, right below the imports:

```js
import dotenv from "dotenv";
dotenv.config();
```

Write the following code inside the already created db.ts file:

```js
import * as mongoDB from "mongodb";
import { MongoMemoryServer } from "mongodb-memory-server";

// TypeScript type for form data
export type BlogPostFormData = {
  blogId: string;
  blogTitle: string;
  blogText: string;
};

// TypeScript interface for our blog post database entry
export interface BlogPost {
  // https://www.mongodb.com/docs/drivers/node/current/typescript/#working-with-the-_id-field
  _id?: mongoDB.ObjectId;
  blogTitle: string;
  blogText: string;
}

// clean way to have types for our database collections
export const collections: {
  // https://www.mongodb.com/docs/drivers/node/current/typescript/#working-with-the-_id-field
  blogPosts?: mongoDB.Collection<mongoDB.OptionalId<BlogPost>>;
} = {};

// we initialise the db and decide if we are testing
export async function connectToDatabase(isTesting: boolean) {
  // this is the connection string to connect to our database
  let connectionString;
  // if testing we use mongodb-memory-server
  if (isTesting) {
    const mongod = await MongoMemoryServer.create({
      instance: {
        dbName: "my-project",
      },
    });
    connectionString = mongod.getUri();
  } else {
    // else we use a real database
    connectionString = process.env.MONGODB_CONNECTION_STRING as string;
  }
  // we initialise the client
  const client: mongoDB.MongoClient = new mongoDB.MongoClient(connectionString);
  // and connect to the database server
  await client.connect();
  // we assign our database to a variable
  const db: mongoDB.Db = client.db("my-project");
  // and our blog post collection to another variable
  const blogCollection = db.collection<mongoDB.OptionalId<BlogPost>>("posts");
  // then assign it to our collections object
  collections.blogPosts = blogCollection;
  // logging that we are up and running
  console.log(
    "succefully connected to database with mongoDB client and app collections..."
  );
}
```

Let's move on and create two files, one to hold the Express route logic for our dashboard page, and one for our validation logic to validate our blog post form data.

- Create dashboardController.ts inside your /src/backend/controllers directory
- Create validate.ts inside your /src/backend directory

The file tree should look like this:
```bash
src/backend/
â”œâ”€â”€ controllers
â”‚   â””â”€â”€ dashboardController.ts <- newly created
â”œâ”€â”€ db.ts
â””â”€â”€ validate.ts <- newly created
```

Put this code inside validate.ts:
```js
import type { BlogPostFormData } from "./db";

// simple validation function just to have something to test
export function validateBlogPostFormData(formData: BlogPostFormData) {
  const blogTitle = formData.blogTitle;
  const blogText = formData.blogText;
  // we validate if blog title and blog text are strings with >0 characters
  if (typeof blogTitle === "string" || typeof blogText === "string") {
    if (blogTitle.length > 0 && blogText.length > 0) {
      return true;
    }
  }
  // otherwise the validation fails
  return false;
}
```

And this code inside the dashboardController.ts:
```js
import type { Request, Response } from "express";
import { collections } from "../db";
import type { BlogPostFormData } from "../db";
import { validateBlogPostFormData } from "../validate";

// simple async function to load into our express route
export async function dashboard(req: Request, res: Response) {
  // we extract the form data from the request
  const formData: BlogPostFormData = req.body;
  // validate form data
  if (!validateBlogPostFormData(formData)) {
    // send error message for invalid form data
    return res.status(400).send("Bad Request");
  }
  try {
    // try save to the database
    await collections.blogPosts?.insertOne(formData);
    // send success message
    res.sendStatus(200);
  } catch (error) {
    // send error message for unknown error
    res.status(500).send("Internal Server Error");
  }
}
```

Now we can add the database connection and the Express route logic to our server.ts file.
```js
async function main() { // old code 
  await connectToDatabase(process.env.NODE_ENV === "test");

  const app = express(); // old code
  app.post("/dashboard", dashboard);
```

### That's enough to start writing some tests:

coming soon...
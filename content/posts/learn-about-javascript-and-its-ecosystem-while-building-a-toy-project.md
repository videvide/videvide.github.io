---
date: '2025-10-12T15:23:53+02:00'
draft: true
title: 'Learn About JavaScript and Its Ecosystem While Building a Toy Project ðŸª€'
tags: ["javascript", "node", "vite", "typescript", "express", "mongodb"]
categories: ["full-stack"]
---
##### Disclaimer: This is not something anyone would normally do, but because we are learning, this is exactly what we want to do. This will give you a better understanding of the moving parts and why you later would want to use a framework that basically do all of this for you.

### Steps to take...

...to build a full-stack [Node](https://nodejs.org/en)/[Express](https://expressjs.com/) app serving a [Single-page application (SPA)](https://developer.mozilla.org/en-US/docs/Glossary/SPA) with client-side navigation using Vite as build tool.

- Pick a project you want to build e.g. a blog or a portfolio.
- Use [Node](https://nodejs.org/en) as backend environment.
- Use [Vite](https://vite.dev/) as build tool.
- Use [TypeScript](https://www.typescriptlang.org/).
- Use [Express](https://expressjs.com/) as web server.
- Use [Fetch (Fetch API)](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API).
- Use [Vitest](https://vitest.dev/) to unit test.
- Use [Playwright](https://playwright.dev/) to end-2-end test.
- Use [GitHub](https://github.com/) and [GitHub Actions](https://github.com/features/actions).
- Use [MongoDB](https://www.mongodb.com/) with [Node native MongoDB client driver](https://www.mongodb.com/docs/drivers/node/current/).
- Host the production app on [Render.com](https://render.com/).
- Host the production MongoDB on [MongoDB Atlas](https://www.mongodb.com/products/platform/atlas-database).

You can read more about each technology on the specific websites, and you can use AI-tools to help you better understand why they exist and why we use them. In this guide I'll provide simple explanations, but the focus is on the code itself.

### Let's get started

I'm running macOS, you need to replace the terminal commands to match your OS.

- Make sure you have Node installed on your system.
- Make sure you have a text editor e.g. Visual Studio Code

### Create a Vite project

Vite is a build tool for the JavaScript ecosystem, it transforms different types of code like TypeScript into pure Javascript that the browser and other runtimes can understand. This tool is essential for us to develop modern web applications.

We start [creating a new Vite project](https://vite.dev/guide/#scaffolding-your-first-vite-project) without framework (Vanilla), with TypeScript and without rolldown-vite:
```bash
npm create vite@latest my-project
```
output:
```bash
â—‡  Select a framework:
â”‚  Vanilla
â”‚
â—‡  Select a variant:
â”‚  TypeScript
â”‚
â—‡  Use rolldown-vite (Experimental)?:
â”‚  No
â”‚
â—‡  Install with npm and start now?
â”‚  No
```

We then follow the instructions to navigate into our project, installing all dependencies, and starting the dev server: 
```bash
 cd my-project
 npm install
 npm run dev
```
output:
```bash
  VITE v7.1.9  ready in 269 ms

  âžœ  Local:   http://localhost:5173/
  âžœ  Network: use --host to expose
  âžœ  press h + enter to show help
```

Open the browser and navigate to [http://localhost:5173/](http://localhost:5173/) to view the app.

This is the default app generated by the Vite team, now we'll begin buidling our own app.

### What's in our project so far?

We have the basic directories and files to build a JavaScript app. 

The node_modules directory contains all installed dependencies that we need to develop our project, it's to large to list but check it out for yourself, you'll find vite in there.
```bash
.
â”œâ”€â”€ .gitignore
â”œâ”€â”€ index.html
â”œâ”€â”€ node_modules
â”œâ”€â”€ package-lock.json
â”œâ”€â”€ package.json
â”œâ”€â”€ public
â”‚Â Â  â””â”€â”€ vite.svg
â”œâ”€â”€ src
â”‚Â Â  â”œâ”€â”€ counter.ts
â”‚Â Â  â”œâ”€â”€ main.ts
â”‚Â Â  â”œâ”€â”€ style.css
â”‚Â Â  â””â”€â”€ typescript.svg
â””â”€â”€ tsconfig.json
```

I'll explain their purpose:

.gitignore
: This file tells git what not to commit to our repository.

index.html
: This file is the starting point for our frontend.

/node_modules
: This directory is where all dependencies lives. Whenever we install a new package it ends up in here.

package-lock.json
: This file keeps track of all installed dependencies, and their respective dependencies. We do not touch this file, it's entirely managed by our package manager (npm).

package.json
: This file is our projects configuration file, in here we specify what dependecies we want to include and what scripts we want to run, e.g. the dev script which starts our dev server.

/public
: This directory contains images and other static files which are not HTML, CSS, or JavaScript.

/src
: This directory is where we keep most of our projects source files, i.e. where we keep most of our application code. 

tsconfig.json
: This file is our projects TypeScript configuration file, we use this file to tell the TypeScript Server what we expect it to behave while interacting with our projects code.  

#### Again, use AI-tools to further explain the files and directories.

### Let's do some cleaning ðŸ§¹

Before we add our own files we remove the files inside /src and /public. These files are not needed to run our application, they are there to run the current default application.

- Remove vite.svg
- Remove counter.ts
- Remove main.ts
- Remove style.css
- Remove typescript.svg

Now we're ready to start adding our own code. I'll walk you through the steps.

### Soon we start coding, let's start with project structure

We want to split our backend and frontend code into two seperate directories, and to have it organised we create the directories inside our /src directory: 

```bash
src/
â”œâ”€â”€ backend
â””â”€â”€ frontend
```

We keep the index.html file in the root directory of our project, this is still the entry point for our frontend/client code.

Now we create the file that will act as the entry point for our backend/server code. 

- Create a file and name it server.ts and place it in the root directory of the project.

Your project structure should look like this: 

```bash
.
â”œâ”€â”€ index.html
â”œâ”€â”€ node_modules
â”œâ”€â”€ package-lock.json
â”œâ”€â”€ package.json
â”œâ”€â”€ public
â”œâ”€â”€ server.ts
â”œâ”€â”€ src
â”‚   â”œâ”€â”€ backend
â”‚   â””â”€â”€ frontend
â””â”€â”€ tsconfig.json
```

To explain, we run our app in developmenr by calling the server.ts file with a package called tsx that can run the TypeScript file. Later in production when the project is already transpiled into JavaScript we use Node.

```bash
# in development: 
tsx server.ts
# in production: 
node server.js
```

It's inside this server.ts/js file we initialise our application and serve the client code as static files through our express web server. 

On top of that we use Vite in development, as an express middleware, to get all the benefits Vite provides, e.g. [HMR (Hot Module Replacement)](https://vite.dev/guide/features.html#hot-module-replacement) which updates the browser output automatically on code changes in our editor. 

Don't worry, this will soon all make sense.

In order to have full TypeScript support we add our server.ts file to our tsconfig.json:

```js
"include": ["src", "server.ts"]
```

Before we start coding we add some more fundamental files to our project structure.

- Create a file named router.ts inside your /src/frontend directory.
- Create a file named routes.ts inside your /src/frontend directory.
- Create a directory named pages inside your /src/frontend directory.
- Create a directory named controllers inside your /src/backend directory.
- Create a file named db.ts inside yout /src/backend directory.

Your project structure should look like this:

```bash
.
â”œâ”€â”€ index.html
â”œâ”€â”€ node_modules
â”œâ”€â”€ package-lock.json
â”œâ”€â”€ package.json
â”œâ”€â”€ public
â”œâ”€â”€ server.ts
â”œâ”€â”€ src
â”‚   â”œâ”€â”€ backend
â”‚   â”‚   â”œâ”€â”€ controllers
â”‚   â”‚   â””â”€â”€ db.ts
â”‚   â””â”€â”€ frontend
â”‚       â”œâ”€â”€ pages
â”‚       â”œâ”€â”€ router.ts
â”‚       â””â”€â”€ routes.ts
â””â”€â”€ tsconfig.json
```

To prevent the app from crashing when we later start it, change the src value inside the script tag inside the index.html to reference your router.ts file:

```html
<script type="module" src="src/frontend/router.ts"></script>
```

### Let's build the backend and glue it to the frontend

Just to recap what happens Whenever a user decides to visit our webpage. Their browser sends a HTTP request asking for whatever we serve at the specific location, usually "/" which could be thought of as "Home". E.g. https://example.com 

When that happens we want to send back a HTTP response, and to do that we need to setup an express web server that listens to incoming requests and serves our SPA.

**We install a couple of packages to get going.**

The -D flag installs a package only to the devDependencies to use only in development.

To please TypeScript we install types for Node:

```bash
npm i -D @types/node 
```

Then the tsx package which allows us to run our server.ts file in development:

```bash
npm i -D tsx
```

Finally, install express and its types:

```bash
npm i express && npm i -D @types/express
```

Place the following code inside your server.ts file:

```js
import express, { type Response } from "express";
import path from "path";
import { fileURLToPath } from "url";

const port = 3000;

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

async function main() {
  const app = express();
  app.get("/", ({ res }: { res: Response }) => {
    res.sendFile(path.join(__dirname, "index.html"));
  });
  app.listen(port, () => {
    console.log(`running server at http://localhost:${port}`);
  });
}

main().catch((error) => console.log(error));
```

Change the dev script inside package.json to run with tsx:
```js
"dev": "tsx server.ts"
```

Then run the server from the terminal:

```bash
npm run dev
```

It should give an output like this: 

```bash
> my-project@0.0.0 dev
> tsx server.ts

running server at http://localhost:3000
```

Visit the site, it's only a blank page, but the title of the site should be "my-project". 

**Hint: The title is visible in the tab at the top of the browser.**

### What's happening right now?

Let's break it down...

We import the express package and its types to be able to build the web server:
```js
import express, { type Response } from "express";
```

We import the path package which allows us to easily write and handle path strings. This is important to tell the code inside the current module how to navigate the filesystem:
```js
import path from "path";
```

The third import is a function that allows us to transform a file url into a path that the path package can understand:
```bash
# file url
file:///Users/vide/code/my-project/server.ts
# file path
/Users/vide/code/my-project/server.ts
```
```js
import { fileURLToPath } from "url";
```

We assign the port number to a constant, and populate the current filename and dirname to two other constant: 

```js
const port = 3000; // port number for our server

const __filename = fileURLToPath(import.meta.url); // server.ts
const __dirname = path.dirname(__filename); // /Users/vide/code/my-project/
```

- We wrap our express server inside a main function.
- We create a "GET" endpoint for the express server and serve our index.html file when the site is visited.
- We tell express to listen on our predefined port and console.log that it is running.
- Finally, we initialise the main function with a catch handler to console.log any errors. 

```js
async function main() {
  const app = express();
  app.get("/", ({ res }: { res: Response }) => {
    res.sendFile(path.join(__dirname, "index.html"));
  });
  app.listen(port, () => {
    console.log(`running server at http://localhost:${port}`);
  });
}

main().catch((error) => console.log(error));
```

### Time to connect Vite with Express 

##### [View the source](https://vite.dev/guide/ssr)

In order to have the benefits of Vite in our development process, we need to set it up as a Express middleware and tell it to serve our frontend code as a SPA. 

We need to distinguish between dev mode and production mode, and the easiest way to do that is to set an environment variable.

There is a great package we can use to achieve this rather hassle free: [cross-env](https://www.npmjs.com/package/cross-env). This package can be used on macOS, Windows, and Linux.

```bash
npm i cross-env
```

It's ready to be used in our code like so, and this gives us the ability to tell the code if it is in production mode or not, deciding if we should run Vite as an Express middleware:
```js
const isProduction = process.env.NODE_ENV === 'production'
```

When we run Vite as a middleware, Vite also want to know where to find our index.html, but Vite will look for index.html by default so we do not need to specify the exact file to find, as we did above with pure a Express server, only the directory where it is.

Now we need to change the rest of our server.ts file. 

```js
import express, { type Response } from "express";
import path from "path";
import { fileURLToPath } from "url";

const port = 3000;
const isProduction = process.env.NODE_ENV === "production";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

async function main() {
  const app = express();

  let vite;
  if (!isProduction) {
    const { createServer: createViteServer } = await import("vite");
    vite = await createViteServer({
      server: { middlewareMode: true },
      appType: "spa",
      root: __dirname,
    });
    app.use(vite.middlewares);
  } else {
    app.get("/", ({ res }: { res: Response }) => {
      res.sendFile(path.join(__dirname, "index.html"));
    });
  }
  app.listen(port, () => {
    console.log(
      `running ${
        isProduction ? "PROD" : "DEV"
      } server at http://localhost:${port}`
    );
  });
}

main().catch((error) => console.log(error));
```

This checks if we are in dev or production then run correct code:
```js
let vite;
  if (!isProduction) {
    const { createServer: createViteServer } = await import("vite");
    vite = await createViteServer({
      server: { middlewareMode: true },
      appType: "spa",
      root: __dirname,
    });
    app.use(vite.middlewares);
  } else {
    app.get("/", ({ res }: { res: Response }) => {
      res.sendFile(path.join(__dirname, "index.html"));
    });
  }
```

We also add this to print to the console what type of server we are running:
```js
  app.listen(port, () => {
    console.log(
      `running ${
        isProduction ? "PROD" : "DEV"
      } server at http://localhost:${port}`
    );
  });
```

To test that everything is working as expected, we start our dev server then visit the web page in the browser, then we add a h1 tag inside our index.html file saying "Hello, World!" and save. It should render in the browser without any server restart. 

We can now move on to more client/frontend specific code.

### Client-side navigation and routing 

...coming soon